<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/bigtable/v2/bigtable.proto

namespace Google\Bigtable\V2;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * Specifies a piece of a row's contents returned as part of the read
 * response stream.
 * </pre>
 *
 * Protobuf type <code>google.bigtable.v2.ReadRowsResponse.CellChunk</code>
 */
class ReadRowsResponse_CellChunk extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * The row key for this chunk of data.  If the row key is empty,
     * this CellChunk is a continuation of the same row as the previous
     * CellChunk in the response stream, even if that CellChunk was in a
     * previous ReadRowsResponse message.
     * </pre>
     *
     * <code>bytes row_key = 1;</code>
     */
    private $row_key = '';
    /**
     * <pre>
     * The column family name for this chunk of data.  If this message
     * is not present this CellChunk is a continuation of the same column
     * family as the previous CellChunk.  The empty string can occur as a
     * column family name in a response so clients must check
     * explicitly for the presence of this message, not just for
     * `family_name.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.StringValue family_name = 2;</code>
     */
    private $family_name = null;
    /**
     * <pre>
     * The column qualifier for this chunk of data.  If this message
     * is not present, this CellChunk is a continuation of the same column
     * as the previous CellChunk.  Column qualifiers may be empty so
     * clients must check for the presence of this message, not just
     * for `qualifier.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.BytesValue qualifier = 3;</code>
     */
    private $qualifier = null;
    /**
     * <pre>
     * The cell's stored timestamp, which also uniquely identifies it
     * within its column.  Values are always expressed in
     * microseconds, but individual tables may set a coarser
     * granularity to further restrict the allowed values. For
     * example, a table which specifies millisecond granularity will
     * only allow values of `timestamp_micros` which are multiples of
     * 1000.  Timestamps are only set in the first CellChunk per cell
     * (for cells split into multiple chunks).
     * </pre>
     *
     * <code>int64 timestamp_micros = 4;</code>
     */
    private $timestamp_micros = 0;
    /**
     * <pre>
     * Labels applied to the cell by a
     * [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
     * on the first CellChunk per cell.
     * </pre>
     *
     * <code>repeated string labels = 5;</code>
     */
    private $labels;
    /**
     * <pre>
     * The value stored in the cell.  Cell values can be split across
     * multiple CellChunks.  In that case only the value field will be
     * set in CellChunks after the first: the timestamp and labels
     * will only be present in the first CellChunk, even if the first
     * CellChunk came in a previous ReadRowsResponse.
     * </pre>
     *
     * <code>bytes value = 6;</code>
     */
    private $value = '';
    /**
     * <pre>
     * If this CellChunk is part of a chunked cell value and this is
     * not the final chunk of that cell, value_size will be set to the
     * total length of the cell value.  The client can use this size
     * to pre-allocate memory to hold the full cell value.
     * </pre>
     *
     * <code>int32 value_size = 7;</code>
     */
    private $value_size = 0;
    protected $row_status;

    public function __construct() {
        \GPBMetadata\Google\Bigtable\V2\Bigtable::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * The row key for this chunk of data.  If the row key is empty,
     * this CellChunk is a continuation of the same row as the previous
     * CellChunk in the response stream, even if that CellChunk was in a
     * previous ReadRowsResponse message.
     * </pre>
     *
     * <code>bytes row_key = 1;</code>
     */
    public function getRowKey()
    {
        return $this->row_key;
    }

    /**
     * <pre>
     * The row key for this chunk of data.  If the row key is empty,
     * this CellChunk is a continuation of the same row as the previous
     * CellChunk in the response stream, even if that CellChunk was in a
     * previous ReadRowsResponse message.
     * </pre>
     *
     * <code>bytes row_key = 1;</code>
     */
    public function setRowKey($var)
    {
        GPBUtil::checkString($var, False);
        $this->row_key = $var;
    }

    /**
     * <pre>
     * The column family name for this chunk of data.  If this message
     * is not present this CellChunk is a continuation of the same column
     * family as the previous CellChunk.  The empty string can occur as a
     * column family name in a response so clients must check
     * explicitly for the presence of this message, not just for
     * `family_name.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.StringValue family_name = 2;</code>
     */
    public function getFamilyName()
    {
        return $this->family_name;
    }

    /**
     * <pre>
     * The column family name for this chunk of data.  If this message
     * is not present this CellChunk is a continuation of the same column
     * family as the previous CellChunk.  The empty string can occur as a
     * column family name in a response so clients must check
     * explicitly for the presence of this message, not just for
     * `family_name.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.StringValue family_name = 2;</code>
     */
    public function setFamilyName(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\StringValue::class);
        $this->family_name = $var;
    }

    /**
     * <pre>
     * The column qualifier for this chunk of data.  If this message
     * is not present, this CellChunk is a continuation of the same column
     * as the previous CellChunk.  Column qualifiers may be empty so
     * clients must check for the presence of this message, not just
     * for `qualifier.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.BytesValue qualifier = 3;</code>
     */
    public function getQualifier()
    {
        return $this->qualifier;
    }

    /**
     * <pre>
     * The column qualifier for this chunk of data.  If this message
     * is not present, this CellChunk is a continuation of the same column
     * as the previous CellChunk.  Column qualifiers may be empty so
     * clients must check for the presence of this message, not just
     * for `qualifier.value` being non-empty.
     * </pre>
     *
     * <code>.google.protobuf.BytesValue qualifier = 3;</code>
     */
    public function setQualifier(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\BytesValue::class);
        $this->qualifier = $var;
    }

    /**
     * <pre>
     * The cell's stored timestamp, which also uniquely identifies it
     * within its column.  Values are always expressed in
     * microseconds, but individual tables may set a coarser
     * granularity to further restrict the allowed values. For
     * example, a table which specifies millisecond granularity will
     * only allow values of `timestamp_micros` which are multiples of
     * 1000.  Timestamps are only set in the first CellChunk per cell
     * (for cells split into multiple chunks).
     * </pre>
     *
     * <code>int64 timestamp_micros = 4;</code>
     */
    public function getTimestampMicros()
    {
        return $this->timestamp_micros;
    }

    /**
     * <pre>
     * The cell's stored timestamp, which also uniquely identifies it
     * within its column.  Values are always expressed in
     * microseconds, but individual tables may set a coarser
     * granularity to further restrict the allowed values. For
     * example, a table which specifies millisecond granularity will
     * only allow values of `timestamp_micros` which are multiples of
     * 1000.  Timestamps are only set in the first CellChunk per cell
     * (for cells split into multiple chunks).
     * </pre>
     *
     * <code>int64 timestamp_micros = 4;</code>
     */
    public function setTimestampMicros($var)
    {
        GPBUtil::checkInt64($var);
        $this->timestamp_micros = $var;
    }

    /**
     * <pre>
     * Labels applied to the cell by a
     * [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
     * on the first CellChunk per cell.
     * </pre>
     *
     * <code>repeated string labels = 5;</code>
     */
    public function getLabels()
    {
        return $this->labels;
    }

    /**
     * <pre>
     * Labels applied to the cell by a
     * [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
     * on the first CellChunk per cell.
     * </pre>
     *
     * <code>repeated string labels = 5;</code>
     */
    public function setLabels(&$var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->labels = $arr;
    }

    /**
     * <pre>
     * The value stored in the cell.  Cell values can be split across
     * multiple CellChunks.  In that case only the value field will be
     * set in CellChunks after the first: the timestamp and labels
     * will only be present in the first CellChunk, even if the first
     * CellChunk came in a previous ReadRowsResponse.
     * </pre>
     *
     * <code>bytes value = 6;</code>
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * <pre>
     * The value stored in the cell.  Cell values can be split across
     * multiple CellChunks.  In that case only the value field will be
     * set in CellChunks after the first: the timestamp and labels
     * will only be present in the first CellChunk, even if the first
     * CellChunk came in a previous ReadRowsResponse.
     * </pre>
     *
     * <code>bytes value = 6;</code>
     */
    public function setValue($var)
    {
        GPBUtil::checkString($var, False);
        $this->value = $var;
    }

    /**
     * <pre>
     * If this CellChunk is part of a chunked cell value and this is
     * not the final chunk of that cell, value_size will be set to the
     * total length of the cell value.  The client can use this size
     * to pre-allocate memory to hold the full cell value.
     * </pre>
     *
     * <code>int32 value_size = 7;</code>
     */
    public function getValueSize()
    {
        return $this->value_size;
    }

    /**
     * <pre>
     * If this CellChunk is part of a chunked cell value and this is
     * not the final chunk of that cell, value_size will be set to the
     * total length of the cell value.  The client can use this size
     * to pre-allocate memory to hold the full cell value.
     * </pre>
     *
     * <code>int32 value_size = 7;</code>
     */
    public function setValueSize($var)
    {
        GPBUtil::checkInt32($var);
        $this->value_size = $var;
    }

    /**
     * <pre>
     * Indicates that the client should drop all previous chunks for
     * `row_key`, as it will be re-read from the beginning.
     * </pre>
     *
     * <code>bool reset_row = 8;</code>
     */
    public function getResetRow()
    {
        return $this->readOneof(8);
    }

    /**
     * <pre>
     * Indicates that the client should drop all previous chunks for
     * `row_key`, as it will be re-read from the beginning.
     * </pre>
     *
     * <code>bool reset_row = 8;</code>
     */
    public function setResetRow($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(8, $var);
    }

    /**
     * <pre>
     * Indicates that the client can safely process all previous chunks for
     * `row_key`, as its data has been fully read.
     * </pre>
     *
     * <code>bool commit_row = 9;</code>
     */
    public function getCommitRow()
    {
        return $this->readOneof(9);
    }

    /**
     * <pre>
     * Indicates that the client can safely process all previous chunks for
     * `row_key`, as its data has been fully read.
     * </pre>
     *
     * <code>bool commit_row = 9;</code>
     */
    public function setCommitRow($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(9, $var);
    }

    public function getRowStatus()
    {
        return $this->whichOneof("row_status");
    }

}

