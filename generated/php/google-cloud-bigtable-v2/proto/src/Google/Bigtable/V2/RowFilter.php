<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/bigtable/v2/data.proto

namespace Google\Bigtable\V2;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * Takes a row as input and produces an alternate view of the row based on
 * specified rules. For example, a RowFilter might trim down a row to include
 * just the cells from columns matching a given regular expression, or might
 * return all the cells of a row but not their values. More complicated filters
 * can be composed out of these components to express requests such as, "within
 * every column of a particular family, give just the two most recent cells
 * which are older than timestamp X."
 * There are two broad categories of RowFilters (true filters and transformers),
 * as well as two ways to compose simple filters into more complex ones
 * (chains and interleaves). They work as follows:
 * * True filters alter the input row by excluding some of its cells wholesale
 * from the output row. An example of a true filter is the `value_regex_filter`,
 * which excludes cells whose values don't match the specified pattern. All
 * regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
 * in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
 * important point to keep in mind is that `RE2(.)` is equivalent by default to
 * `RE2([^&#92;n])`, meaning that it does not match newlines. When attempting to
 * match an arbitrary byte, you should therefore use the escape sequence `&#92;C`,
 * which may need to be further escaped as `&#92;&#92;C` in your client language.
 * * Transformers alter the input row by changing the values of some of its
 * cells in the output, without excluding them completely. Currently, the only
 * supported transformer is the `strip_value_transformer`, which replaces every
 * cell's value with the empty string.
 * * Chains and interleaves are described in more detail in the
 * RowFilter.Chain and RowFilter.Interleave documentation.
 * The total serialized size of a RowFilter message must not
 * exceed 4096 bytes, and RowFilters may not be nested within each other
 * (in Chains or Interleaves) to a depth of more than 20.
 * </pre>
 *
 * Protobuf type <code>google.bigtable.v2.RowFilter</code>
 */
class RowFilter extends \Google\Protobuf\Internal\Message
{
    protected $filter;

    public function __construct() {
        \GPBMetadata\Google\Bigtable\V2\Data::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * Applies several RowFilters to the data in sequence, progressively
     * narrowing the results.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Chain chain = 1;</code>
     */
    public function getChain()
    {
        return $this->readOneof(1);
    }

    /**
     * <pre>
     * Applies several RowFilters to the data in sequence, progressively
     * narrowing the results.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Chain chain = 1;</code>
     */
    public function setChain(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\RowFilter_Chain::class);
        $this->writeOneof(1, $var);
    }

    /**
     * <pre>
     * Applies several RowFilters to the data in parallel and combines the
     * results.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Interleave interleave = 2;</code>
     */
    public function getInterleave()
    {
        return $this->readOneof(2);
    }

    /**
     * <pre>
     * Applies several RowFilters to the data in parallel and combines the
     * results.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Interleave interleave = 2;</code>
     */
    public function setInterleave(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\RowFilter_Interleave::class);
        $this->writeOneof(2, $var);
    }

    /**
     * <pre>
     * Applies one of two possible RowFilters to the data based on the output of
     * a predicate RowFilter.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Condition condition = 3;</code>
     */
    public function getCondition()
    {
        return $this->readOneof(3);
    }

    /**
     * <pre>
     * Applies one of two possible RowFilters to the data based on the output of
     * a predicate RowFilter.
     * </pre>
     *
     * <code>.google.bigtable.v2.RowFilter.Condition condition = 3;</code>
     */
    public function setCondition(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\RowFilter_Condition::class);
        $this->writeOneof(3, $var);
    }

    /**
     * <pre>
     * ADVANCED USE ONLY.
     * Hook for introspection into the RowFilter. Outputs all cells directly to
     * the output of the read rather than to any parent filter. Consider the
     * following example:
     *     Chain(
     *       FamilyRegex("A"),
     *       Interleave(
     *         All(),
     *         Chain(Label("foo"), Sink())
     *       ),
     *       QualifierRegex("B")
     *     )
     *                         A,A,1,w
     *                         A,B,2,x
     *                         B,B,4,z
     *                            |
     *                     FamilyRegex("A")
     *                            |
     *                         A,A,1,w
     *                         A,B,2,x
     *                            |
     *               +------------+-------------+
     *               |                          |
     *             All()                    Label(foo)
     *               |                          |
     *            A,A,1,w              A,A,1,w,labels:[foo]
     *            A,B,2,x              A,B,2,x,labels:[foo]
     *               |                          |
     *               |                        Sink() --------------+
     *               |                          |                  |
     *               +------------+      x------+          A,A,1,w,labels:[foo]
     *                            |                        A,B,2,x,labels:[foo]
     *                         A,A,1,w                             |
     *                         A,B,2,x                             |
     *                            |                                |
     *                    QualifierRegex("B")                      |
     *                            |                                |
     *                         A,B,2,x                             |
     *                            |                                |
     *                            +--------------------------------+
     *                            |
     *                         A,A,1,w,labels:[foo]
     *                         A,B,2,x,labels:[foo]  // could be switched
     *                         A,B,2,x               // could be switched
     * Despite being excluded by the qualifier filter, a copy of every cell
     * that reaches the sink is present in the final result.
     * As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
     * duplicate cells are possible, and appear in an unspecified mutual order.
     * In this case we have a duplicate with column "A:B" and timestamp 2,
     * because one copy passed through the all filter while the other was
     * passed through the label and sink. Note that one copy has label "foo",
     * while the other does not.
     * Cannot be used within the `predicate_filter`, `true_filter`, or
     * `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
     * </pre>
     *
     * <code>bool sink = 16;</code>
     */
    public function getSink()
    {
        return $this->readOneof(16);
    }

    /**
     * <pre>
     * ADVANCED USE ONLY.
     * Hook for introspection into the RowFilter. Outputs all cells directly to
     * the output of the read rather than to any parent filter. Consider the
     * following example:
     *     Chain(
     *       FamilyRegex("A"),
     *       Interleave(
     *         All(),
     *         Chain(Label("foo"), Sink())
     *       ),
     *       QualifierRegex("B")
     *     )
     *                         A,A,1,w
     *                         A,B,2,x
     *                         B,B,4,z
     *                            |
     *                     FamilyRegex("A")
     *                            |
     *                         A,A,1,w
     *                         A,B,2,x
     *                            |
     *               +------------+-------------+
     *               |                          |
     *             All()                    Label(foo)
     *               |                          |
     *            A,A,1,w              A,A,1,w,labels:[foo]
     *            A,B,2,x              A,B,2,x,labels:[foo]
     *               |                          |
     *               |                        Sink() --------------+
     *               |                          |                  |
     *               +------------+      x------+          A,A,1,w,labels:[foo]
     *                            |                        A,B,2,x,labels:[foo]
     *                         A,A,1,w                             |
     *                         A,B,2,x                             |
     *                            |                                |
     *                    QualifierRegex("B")                      |
     *                            |                                |
     *                         A,B,2,x                             |
     *                            |                                |
     *                            +--------------------------------+
     *                            |
     *                         A,A,1,w,labels:[foo]
     *                         A,B,2,x,labels:[foo]  // could be switched
     *                         A,B,2,x               // could be switched
     * Despite being excluded by the qualifier filter, a copy of every cell
     * that reaches the sink is present in the final result.
     * As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
     * duplicate cells are possible, and appear in an unspecified mutual order.
     * In this case we have a duplicate with column "A:B" and timestamp 2,
     * because one copy passed through the all filter while the other was
     * passed through the label and sink. Note that one copy has label "foo",
     * while the other does not.
     * Cannot be used within the `predicate_filter`, `true_filter`, or
     * `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
     * </pre>
     *
     * <code>bool sink = 16;</code>
     */
    public function setSink($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(16, $var);
    }

    /**
     * <pre>
     * Matches all cells, regardless of input. Functionally equivalent to
     * leaving `filter` unset, but included for completeness.
     * </pre>
     *
     * <code>bool pass_all_filter = 17;</code>
     */
    public function getPassAllFilter()
    {
        return $this->readOneof(17);
    }

    /**
     * <pre>
     * Matches all cells, regardless of input. Functionally equivalent to
     * leaving `filter` unset, but included for completeness.
     * </pre>
     *
     * <code>bool pass_all_filter = 17;</code>
     */
    public function setPassAllFilter($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(17, $var);
    }

    /**
     * <pre>
     * Does not match any cells, regardless of input. Useful for temporarily
     * disabling just part of a filter.
     * </pre>
     *
     * <code>bool block_all_filter = 18;</code>
     */
    public function getBlockAllFilter()
    {
        return $this->readOneof(18);
    }

    /**
     * <pre>
     * Does not match any cells, regardless of input. Useful for temporarily
     * disabling just part of a filter.
     * </pre>
     *
     * <code>bool block_all_filter = 18;</code>
     */
    public function setBlockAllFilter($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(18, $var);
    }

    /**
     * <pre>
     * Matches only cells from rows whose keys satisfy the given RE2 regex. In
     * other words, passes through the entire row when the key matches, and
     * otherwise produces an empty row.
     * Note that, since row keys can contain arbitrary bytes, the `&#92;C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `&#92;n`, which may be present in a
     * binary key.
     * </pre>
     *
     * <code>bytes row_key_regex_filter = 4;</code>
     */
    public function getRowKeyRegexFilter()
    {
        return $this->readOneof(4);
    }

    /**
     * <pre>
     * Matches only cells from rows whose keys satisfy the given RE2 regex. In
     * other words, passes through the entire row when the key matches, and
     * otherwise produces an empty row.
     * Note that, since row keys can contain arbitrary bytes, the `&#92;C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `&#92;n`, which may be present in a
     * binary key.
     * </pre>
     *
     * <code>bytes row_key_regex_filter = 4;</code>
     */
    public function setRowKeyRegexFilter($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(4, $var);
    }

    /**
     * <pre>
     * Matches all cells from a row with probability p, and matches no cells
     * from the row with probability 1-p.
     * </pre>
     *
     * <code>double row_sample_filter = 14;</code>
     */
    public function getRowSampleFilter()
    {
        return $this->readOneof(14);
    }

    /**
     * <pre>
     * Matches all cells from a row with probability p, and matches no cells
     * from the row with probability 1-p.
     * </pre>
     *
     * <code>double row_sample_filter = 14;</code>
     */
    public function setRowSampleFilter($var)
    {
        GPBUtil::checkDouble($var);
        $this->writeOneof(14, $var);
    }

    /**
     * <pre>
     * Matches only cells from columns whose families satisfy the given RE2
     * regex. For technical reasons, the regex must not contain the `:`
     * character, even if it is not being used as a literal.
     * Note that, since column families cannot contain the new line character
     * `&#92;n`, it is sufficient to use `.` as a full wildcard when matching
     * column family names.
     * </pre>
     *
     * <code>string family_name_regex_filter = 5;</code>
     */
    public function getFamilyNameRegexFilter()
    {
        return $this->readOneof(5);
    }

    /**
     * <pre>
     * Matches only cells from columns whose families satisfy the given RE2
     * regex. For technical reasons, the regex must not contain the `:`
     * character, even if it is not being used as a literal.
     * Note that, since column families cannot contain the new line character
     * `&#92;n`, it is sufficient to use `.` as a full wildcard when matching
     * column family names.
     * </pre>
     *
     * <code>string family_name_regex_filter = 5;</code>
     */
    public function setFamilyNameRegexFilter($var)
    {
        GPBUtil::checkString($var, True);
        $this->writeOneof(5, $var);
    }

    /**
     * <pre>
     * Matches only cells from columns whose qualifiers satisfy the given RE2
     * regex.
     * Note that, since column qualifiers can contain arbitrary bytes, the `&#92;C`
     * escape sequence must be used if a true wildcard is desired. The `.`
     * character will not match the new line character `&#92;n`, which may be
     * present in a binary qualifier.
     * </pre>
     *
     * <code>bytes column_qualifier_regex_filter = 6;</code>
     */
    public function getColumnQualifierRegexFilter()
    {
        return $this->readOneof(6);
    }

    /**
     * <pre>
     * Matches only cells from columns whose qualifiers satisfy the given RE2
     * regex.
     * Note that, since column qualifiers can contain arbitrary bytes, the `&#92;C`
     * escape sequence must be used if a true wildcard is desired. The `.`
     * character will not match the new line character `&#92;n`, which may be
     * present in a binary qualifier.
     * </pre>
     *
     * <code>bytes column_qualifier_regex_filter = 6;</code>
     */
    public function setColumnQualifierRegexFilter($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(6, $var);
    }

    /**
     * <pre>
     * Matches only cells from columns within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.ColumnRange column_range_filter = 7;</code>
     */
    public function getColumnRangeFilter()
    {
        return $this->readOneof(7);
    }

    /**
     * <pre>
     * Matches only cells from columns within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.ColumnRange column_range_filter = 7;</code>
     */
    public function setColumnRangeFilter(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\ColumnRange::class);
        $this->writeOneof(7, $var);
    }

    /**
     * <pre>
     * Matches only cells with timestamps within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.TimestampRange timestamp_range_filter = 8;</code>
     */
    public function getTimestampRangeFilter()
    {
        return $this->readOneof(8);
    }

    /**
     * <pre>
     * Matches only cells with timestamps within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.TimestampRange timestamp_range_filter = 8;</code>
     */
    public function setTimestampRangeFilter(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\TimestampRange::class);
        $this->writeOneof(8, $var);
    }

    /**
     * <pre>
     * Matches only cells with values that satisfy the given regular expression.
     * Note that, since cell values can contain arbitrary bytes, the `&#92;C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `&#92;n`, which may be present in a
     * binary value.
     * </pre>
     *
     * <code>bytes value_regex_filter = 9;</code>
     */
    public function getValueRegexFilter()
    {
        return $this->readOneof(9);
    }

    /**
     * <pre>
     * Matches only cells with values that satisfy the given regular expression.
     * Note that, since cell values can contain arbitrary bytes, the `&#92;C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `&#92;n`, which may be present in a
     * binary value.
     * </pre>
     *
     * <code>bytes value_regex_filter = 9;</code>
     */
    public function setValueRegexFilter($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(9, $var);
    }

    /**
     * <pre>
     * Matches only cells with values that fall within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.ValueRange value_range_filter = 15;</code>
     */
    public function getValueRangeFilter()
    {
        return $this->readOneof(15);
    }

    /**
     * <pre>
     * Matches only cells with values that fall within the given range.
     * </pre>
     *
     * <code>.google.bigtable.v2.ValueRange value_range_filter = 15;</code>
     */
    public function setValueRangeFilter(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Bigtable\V2\ValueRange::class);
        $this->writeOneof(15, $var);
    }

    /**
     * <pre>
     * Skips the first N cells of each row, matching all subsequent cells.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_row_offset_filter = 10;</code>
     */
    public function getCellsPerRowOffsetFilter()
    {
        return $this->readOneof(10);
    }

    /**
     * <pre>
     * Skips the first N cells of each row, matching all subsequent cells.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_row_offset_filter = 10;</code>
     */
    public function setCellsPerRowOffsetFilter($var)
    {
        GPBUtil::checkInt32($var);
        $this->writeOneof(10, $var);
    }

    /**
     * <pre>
     * Matches only the first N cells of each row.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_row_limit_filter = 11;</code>
     */
    public function getCellsPerRowLimitFilter()
    {
        return $this->readOneof(11);
    }

    /**
     * <pre>
     * Matches only the first N cells of each row.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_row_limit_filter = 11;</code>
     */
    public function setCellsPerRowLimitFilter($var)
    {
        GPBUtil::checkInt32($var);
        $this->writeOneof(11, $var);
    }

    /**
     * <pre>
     * Matches only the most recent N cells within each column. For example,
     * if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
     * skip all earlier cells in `foo:bar`, and then begin matching again in
     * column `foo:bar2`.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_column_limit_filter = 12;</code>
     */
    public function getCellsPerColumnLimitFilter()
    {
        return $this->readOneof(12);
    }

    /**
     * <pre>
     * Matches only the most recent N cells within each column. For example,
     * if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
     * skip all earlier cells in `foo:bar`, and then begin matching again in
     * column `foo:bar2`.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     * </pre>
     *
     * <code>int32 cells_per_column_limit_filter = 12;</code>
     */
    public function setCellsPerColumnLimitFilter($var)
    {
        GPBUtil::checkInt32($var);
        $this->writeOneof(12, $var);
    }

    /**
     * <pre>
     * Replaces each cell's value with the empty string.
     * </pre>
     *
     * <code>bool strip_value_transformer = 13;</code>
     */
    public function getStripValueTransformer()
    {
        return $this->readOneof(13);
    }

    /**
     * <pre>
     * Replaces each cell's value with the empty string.
     * </pre>
     *
     * <code>bool strip_value_transformer = 13;</code>
     */
    public function setStripValueTransformer($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(13, $var);
    }

    /**
     * <pre>
     * Applies the given label to all cells in the output row. This allows
     * the client to determine which results were produced from which part of
     * the filter.
     * Values must be at most 15 characters in length, and match the RE2
     * pattern `[a-z0-9&#92;&#92;-]+`
     * Due to a technical limitation, it is not currently possible to apply
     * multiple labels to a cell. As a result, a Chain may have no more than
     * one sub-filter which contains a `apply_label_transformer`. It is okay for
     * an Interleave to contain multiple `apply_label_transformers`, as they
     * will be applied to separate copies of the input. This may be relaxed in
     * the future.
     * </pre>
     *
     * <code>string apply_label_transformer = 19;</code>
     */
    public function getApplyLabelTransformer()
    {
        return $this->readOneof(19);
    }

    /**
     * <pre>
     * Applies the given label to all cells in the output row. This allows
     * the client to determine which results were produced from which part of
     * the filter.
     * Values must be at most 15 characters in length, and match the RE2
     * pattern `[a-z0-9&#92;&#92;-]+`
     * Due to a technical limitation, it is not currently possible to apply
     * multiple labels to a cell. As a result, a Chain may have no more than
     * one sub-filter which contains a `apply_label_transformer`. It is okay for
     * an Interleave to contain multiple `apply_label_transformers`, as they
     * will be applied to separate copies of the input. This may be relaxed in
     * the future.
     * </pre>
     *
     * <code>string apply_label_transformer = 19;</code>
     */
    public function setApplyLabelTransformer($var)
    {
        GPBUtil::checkString($var, True);
        $this->writeOneof(19, $var);
    }

    public function getFilter()
    {
        return $this->whichOneof("filter");
    }

}

